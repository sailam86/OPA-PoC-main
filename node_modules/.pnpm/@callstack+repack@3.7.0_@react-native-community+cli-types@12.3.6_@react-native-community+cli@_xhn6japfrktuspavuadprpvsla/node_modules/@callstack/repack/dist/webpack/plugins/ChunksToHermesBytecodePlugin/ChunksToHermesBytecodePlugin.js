"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ChunksToHermesBytecodePlugin = void 0;

var _path = _interopRequireDefault(require("path"));

var _fsExtra = _interopRequireDefault(require("fs-extra"));

var _webpack = require("webpack");

var _utils = require("./utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Enable Hermes bytecode compilation for the given chunks.
 * This plugin is intended to be used with the `webpack-bundle` command.
 * It will transform the bundle into Hermes bytecode and replace the original bundle with the bytecode.
 * It will also compose the source maps generated by webpack and Hermes.
 *
 * Note: This plugin should only be used for production builds.
 * It is not possible to use this plugin for development builds.
 *
 * Note: You should exclude `index.bundle` from being transformed.
 * The `index.bundle` file is transformed by `react-native` after enabling Hermes in your project.
 *
 * @example ```js
 * // webpack.config.mjs
 * import * as Repack from '@callstack/repack';
 *
 * // ...
 * plugins: [
 *   new Repack.ChunksToHermesBytecodePlugin({
 *    enabled: mode === 'production' && !devServer,
 *    test: /\.(js)?bundle$/,
 *    exclude: /index.bundle$/,
 *   }),
 * ]
 * ```
 *
 * @category Webpack Plugin
 */
class ChunksToHermesBytecodePlugin {
  name = 'ChunksToHermesBytecodePlugin';

  constructor(config) {
    this.config = config;
  }

  apply(compiler) {
    const logger = compiler.getInfrastructureLogger(this.name);

    if (!this.config.enabled) {
      logger.debug('Skipping hermes compilation');
      return;
    }
    /**
     * This plugin will only transform assets that are emitted after the compilation.
     * To ensure that asset is always emitted we disable the `compareBeforeEmit` option
     * which is enabled by default in Webpack.
     *
     * `compareBeforeEmit` option is used to skip emitting assets that are identical to the
     * ones present in build directory, which might result in transformation being
     * skipped when there is a untransformed bundle present in the build directory.
     */


    compiler.options.output.compareBeforeEmit = !!this.config.compareBeforeEmit;

    const reactNativePath = this.config.reactNativePath || _path.default.join(compiler.context, 'node_modules', 'react-native');

    const hermesCLIPath = this.config.hermesCLIPath || (0, _utils.getHermesCLIPath)(reactNativePath);
    compiler.hooks.assetEmitted.tapPromise(this.name, async (file, {
      outputPath
    }) => {
      const shouldTransformAsset = _webpack.ModuleFilenameHelpers.matchObject({
        test: this.config.test,
        include: this.config.include,
        exclude: this.config.exclude
      }, file);

      if (!shouldTransformAsset) {
        return;
      }

      const bundlePath = _path.default.join(outputPath, file);

      const sourceMapPath = `${bundlePath}.map`;
      const useSourceMaps = await _fsExtra.default.pathExists(sourceMapPath);
      logger.debug(`Starting hermes compilation for asset: ${bundlePath}`);
      const {
        sourceMap: hermesSourceMapPath
      } = await (0, _utils.transformBundleToHermesBytecode)({
        hermesCLIPath,
        useSourceMaps,
        bundlePath
      });
      logger.info(`Asset transformed: ${file}`);

      if (useSourceMaps) {
        await (0, _utils.composeSourceMaps)({
          reactNativePath,
          packagerMapPath: sourceMapPath,
          compilerMapPath: hermesSourceMapPath
        });
        logger.info(`Asset sourceMap transformed: ${file}.map`);
      }
    });
  }

}

exports.ChunksToHermesBytecodePlugin = ChunksToHermesBytecodePlugin;
//# sourceMappingURL=ChunksToHermesBytecodePlugin.js.map