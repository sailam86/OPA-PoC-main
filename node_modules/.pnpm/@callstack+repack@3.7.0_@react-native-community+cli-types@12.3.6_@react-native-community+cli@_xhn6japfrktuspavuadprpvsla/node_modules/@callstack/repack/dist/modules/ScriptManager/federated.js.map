{"version":3,"file":"federated.js","names":["ScriptManager","createURLResolver","config","resolvers","key","containers","scriptId","caller","url","replace","chunks","includes","webpackContext","u","undefined","resolver","importModule","containerName","module","scope","__webpack_share_scopes__","__isInitialized","__webpack_init_sharing__","self","shared","loadScript","container","init","factory","get","exports","Federated"],"sources":["../../../src/modules/ScriptManager/federated.ts"],"sourcesContent":["import { ScriptManager } from './ScriptManager';\nimport type { WebpackContext } from './types';\n\n/**\n * Namespace for runtime utilities for Module Federation.\n */\nexport namespace Federated {\n  /**\n   * Resolves URL to a container or a chunk when using Module Federation,\n   * based on given `scriptId` and `caller`.\n   */\n  export type URLResolver = (\n    scriptId: string,\n    caller?: string\n  ) => string | ((webpackContext: WebpackContext) => string) | undefined;\n\n  /**\n   * Configuration options for {@link createURLResolver} for Module Federation.\n   * Allows to configure how created {@link URLResolver} will behave.\n   */\n  export interface URLResolverConfig {\n    /**\n     * A Module Federation container names to URL templates mapping.\n     *\n     * The key in the object is a container name and the value is a template\n     * that will be used to resolve a URL.\n     *\n     * Accepted template params:\n     * - `[name]` - Container name\n     * - `[ext]` - Container extension, eg: `.container.bundle`\n     *\n     * You can omit `[ext]`, if you're using custom extension, in which case, you should\n     * provide extension explicitly. When using custom extension, it's recommended to\n     * provide a URL template for chunks as well using `chunks` property.\n     *\n     * @example\n     * ```ts\n     * {\n     *   containers: {\n     *     app1: 'http://localhost:9000/[name][ext]'\n     *   }\n     * }\n     * ```\n     */\n    containers: Record<string, string>;\n\n    /**\n     * An optional Module Federation container names to URL templates mapping.\n     *\n     * The key in the object is a container names and the value is a template\n     * that will be used to resolve a __chunk__ URL for that container.\n     *\n     * Specifying this property is useful if:\n     * - containers have custom extension (different from `.container.bundle`)\n     * - chunks have custom extensions (different from `.chunk.bundle`)\n     * - chunks have different URL that containers\n     *\n     * When this property is left unspecified, the template URLs are inferred from\n     * `containers` property. The following:\n     * ```\n     * {\n     *   containers: {\n     *     app1: 'http://localhost:9000/[name][ext]\n     *     app2: 'http://localhost:9000/[name].js\n     *   },\n     * }\n     * ```\n     * is equivalent to:\n     * ```ts\n     * {\n     *   containers: {\n     *     app1: 'http://localhost:9000/[name][ext]',\n     *     app2: 'http://localhost:9000/[name].js',\n     *   },\n     *   chunks: {\n     *     app1: 'http://localhost:9000/[name][ext]',\n     *     app2: 'http://localhost:9000/[name].js',\n     *   },\n     * }\n     * ```\n     *\n     * Accepted template params:\n     * - `[name]` - Container name\n     * - `[ext]` - Chunk extension, eg: `.chunk.bundle`\n     *\n     * @example\n     * ```ts\n     * {\n     *   containers: {\n     *     app1: 'http://localhost:9000/[name].container.js',\n     *   },\n     *   chunks: {\n     *     app1: 'http://localhost:9000/chunks/[name][ext]',\n     *   }\n     * }\n     * ```\n     */\n    chunks?: Record<string, string>;\n  }\n\n  /**\n   * Creates URL resolver for Module Federation from provided config.\n   *\n   * @example\n   * ```ts\n   * import { ScriptManager, Script, Federated } from '@callstack/repack/client';\n   *\n   * const resolveURL = Federated.createURLResolver({\n   *   containers: {\n   *     app1: 'http://localhost:9001/[name][ext]',\n   *     app2: 'http://localhost:9002/[name].container.js',\n   *   },\n   *   chunks: {\n   *     app2: 'http://localhost:9002/chunks/[name][ext]',\n   *   },\n   * });\n   *\n   * ScriptManager.shared.addResolver(async (scriptId, caller) => {\n   *   let url;\n   *   if (caller === 'main') {\n   *     url = __DEV__\n   *       ? Script.getDevServerURL(scriptId)\n   *       : Script.getRemoteURL(`http://localhost:9000/${scriptId}`);\n   *   } else {\n   *     url = resolveURL(scriptId, caller);\n   *   }\n   *\n   *   if (!url) {\n   *     return undefined;\n   *   }\n   *\n   *   return {\n   *     url,\n   *     query: {\n   *       platform: Platform.OS,\n   *     },\n   *   };\n   * });\n   * ```\n   *\n   * `createURLResolver` is a abstraction over {@link Script.getRemoteURL},\n   * for example:\n   * ```ts\n   * import { ScriptManager, Federated } from '@callstack/repack/client';\n   *\n   * ScriptManager.shared.addResolver((scriptId, caller) => {\n   *   const resolveURL = Federated.createURLResolver({\n   *     containers: {\n   *       app1: 'http://localhost:9000/[name][ext]',\n   *     },\n   *   });\n   *\n   *   return {\n   *     url: resolveURL(scriptId, caller);\n   *   };\n   * });\n   * ```\n   * is equivalent to:\n   * ```ts\n   * import { ScriptManager, Script } from '@callstack/repack/client';\n   *\n   * ScriptManager.shared.addResolver(async (scriptId, caller) => {\n   *   if (scriptId === 'app1') {\n   *     return {\n   *       url: 'http://localhost:9000/app1.container.bundle',\n   *     };\n   *   }\n   *\n   *   if (caller === 'app1') {\n   *     return {\n   *       url: Script.getRemoteURL(`http://localhost:9000/${scriptId}`),\n   *     };\n   *   }\n   * });\n   * ```\n   *\n   * @param config Configuration for the resolver.\n   * @returns A resolver function which will try to resolve URL based on given `scriptId` and `caller`.\n   */\n  export function createURLResolver(\n    config: Federated.URLResolverConfig\n  ): Federated.URLResolver {\n    const resolvers: Record<string, Federated.URLResolver> = {};\n\n    for (const key in config.containers) {\n      resolvers[key] = (scriptId: string, caller?: string) => {\n        if (scriptId === key) {\n          const url = config.containers[key]\n            .replace(/\\[name\\]/g, scriptId)\n            .replace(/\\[ext\\]/g, '.container.bundle');\n          return url;\n        }\n\n        if (caller === key) {\n          const url = (config.chunks?.[key] ?? config.containers[key]).replace(\n            /\\[name\\]/g,\n            scriptId\n          );\n\n          if (url.includes('[ext]')) {\n            return (webpackContext: WebpackContext) =>\n              webpackContext.u(url.replace(/\\[ext\\]/g, ''));\n          }\n\n          return url;\n        }\n\n        return undefined;\n      };\n    }\n\n    return (scriptId, caller) => {\n      const resolver =\n        (caller ? resolvers[caller] : undefined) ?? resolvers[scriptId];\n\n      return resolver(scriptId, caller);\n    };\n  }\n\n  declare function __webpack_init_sharing__(scope: string): Promise<void>;\n  declare var __webpack_share_scopes__: Record<string, any>;\n  declare var self: Record<string, any>;\n\n  /**\n   * Dynamically imports module from a Module Federation container. Similar to `import('file')`, but\n   * specific to Module Federation. Calling `importModule` will create an async boundary.\n   *\n   * Container will be evaluated only once. If you use `importModule` for the same container twice,\n   * the container will be loaded and evaluated only on the first import.\n   *\n   * Under the hood, `importModule` will call `ScriptManager.shared.loadScript(containerName)`.\n   * This means, a resolver must be added with `ScriptManager.shared.addResolver(...)` beforehand and provided proper\n   * resolution logic to resolve URL based on the `containerName`.\n   *\n   * @param containerName Name of the container - should be the same name provided to\n   * `webpack.container.ModuleFederationPlugin` in `library.name`.\n   * @param module Full name with extension of the module to import from the container - only modules\n   * exposed in `exposes` in `webpack.container.ModuleFederationPlugin` can be used.\n   * @param scope Optional, scope for sharing modules between containers. Defaults to `'default'`.\n   * @returns Exports of given `module` from given container.\n   *\n   * @example\n   * ```ts\n   * import * as React from 'react';\n   * import { Federated } from '@callstack/repack/client';\n   *\n   * const Button = React.lazy(() => Federated.importModule('my-components', './Button.js'));\n   *\n   * const myUtil = await Federated.importModule('my-lib', './myUtil.js');\n   * ```\n   */\n  export async function importModule<Exports = any>(\n    containerName: string,\n    module: string,\n    scope: string = 'default'\n  ): Promise<Exports> {\n    if (\n      !__webpack_share_scopes__[scope] ||\n      !__webpack_share_scopes__[scope].__isInitialized\n    ) {\n      // Initializes the share scope.\n      // This fills it with known provided modules from this build and all remotes.\n      await __webpack_init_sharing__(scope);\n      __webpack_share_scopes__[scope].__isInitialized = true;\n    }\n\n    // Do not use `const container = self[containerName];` here. Once container is loaded\n    // `container` reference is not updated, so `container.__isInitialized`\n    // will crash the application, because of reading property from `undefined`.\n    if (!self[containerName]) {\n      // Download and execute container\n      await ScriptManager.shared.loadScript(containerName);\n    }\n\n    const container = self[containerName];\n\n    if (!container.__isInitialized) {\n      container.__isInitialized = true;\n      // Initialize the container, it may provide shared modules\n      await container.init(__webpack_share_scopes__[scope]);\n    }\n\n    const factory = await container.get(module);\n    const exports = factory();\n    return exports;\n  }\n}\n"],"mappings":"AAAA,SAASA,aAAT,QAA8B,iBAA9B;;AAGA;AACA;AACA;AACA;;;EACE;AACF;AACA;AACA;;EAME;AACF;AACA;AACA;EAgKS,SAASC,iBAAT,CACLC,MADK,EAEkB;IACvB,MAAMC,SAAgD,GAAG,EAAzD;;IAEA,KAAK,MAAMC,GAAX,IAAkBF,MAAM,CAACG,UAAzB,EAAqC;MACnCF,SAAS,CAACC,GAAD,CAAT,GAAiB,CAACE,QAAD,EAAmBC,MAAnB,KAAuC;QACtD,IAAID,QAAQ,KAAKF,GAAjB,EAAsB;UACpB,MAAMI,GAAG,GAAGN,MAAM,CAACG,UAAP,CAAkBD,GAAlB,EACTK,OADS,CACD,WADC,EACYH,QADZ,EAETG,OAFS,CAED,UAFC,EAEW,mBAFX,CAAZ;UAGA,OAAOD,GAAP;QACD;;QAED,IAAID,MAAM,KAAKH,GAAf,EAAoB;UAClB,MAAMI,GAAG,GAAG,CAACN,MAAM,CAACQ,MAAP,GAAgBN,GAAhB,KAAwBF,MAAM,CAACG,UAAP,CAAkBD,GAAlB,CAAzB,EAAiDK,OAAjD,CACV,WADU,EAEVH,QAFU,CAAZ;;UAKA,IAAIE,GAAG,CAACG,QAAJ,CAAa,OAAb,CAAJ,EAA2B;YACzB,OAAQC,cAAD,IACLA,cAAc,CAACC,CAAf,CAAiBL,GAAG,CAACC,OAAJ,CAAY,UAAZ,EAAwB,EAAxB,CAAjB,CADF;UAED;;UAED,OAAOD,GAAP;QACD;;QAED,OAAOM,SAAP;MACD,CAvBD;IAwBD;;IAED,OAAO,CAACR,QAAD,EAAWC,MAAX,KAAsB;MAC3B,MAAMQ,QAAQ,GACZ,CAACR,MAAM,GAAGJ,SAAS,CAACI,MAAD,CAAZ,GAAuBO,SAA9B,KAA4CX,SAAS,CAACG,QAAD,CADvD;MAGA,OAAOS,QAAQ,CAACT,QAAD,EAAWC,MAAX,CAAf;IACD,CALD;EAMD;;;;EAkCM,eAAeS,YAAf,CACLC,aADK,EAELC,MAFK,EAGLC,KAAa,GAAG,SAHX,EAIa;IAClB,IACE,CAACC,wBAAwB,CAACD,KAAD,CAAzB,IACA,CAACC,wBAAwB,CAACD,KAAD,CAAxB,CAAgCE,eAFnC,EAGE;MACA;MACA;MACA,MAAMC,wBAAwB,CAACH,KAAD,CAA9B;MACAC,wBAAwB,CAACD,KAAD,CAAxB,CAAgCE,eAAhC,GAAkD,IAAlD;IACD,CATiB,CAWlB;IACA;IACA;;;IACA,IAAI,CAACE,IAAI,CAACN,aAAD,CAAT,EAA0B;MACxB;MACA,MAAMjB,aAAa,CAACwB,MAAd,CAAqBC,UAArB,CAAgCR,aAAhC,CAAN;IACD;;IAED,MAAMS,SAAS,GAAGH,IAAI,CAACN,aAAD,CAAtB;;IAEA,IAAI,CAACS,SAAS,CAACL,eAAf,EAAgC;MAC9BK,SAAS,CAACL,eAAV,GAA4B,IAA5B,CAD8B,CAE9B;;MACA,MAAMK,SAAS,CAACC,IAAV,CAAeP,wBAAwB,CAACD,KAAD,CAAvC,CAAN;IACD;;IAED,MAAMS,OAAO,GAAG,MAAMF,SAAS,CAACG,GAAV,CAAcX,MAAd,CAAtB;IACA,MAAMY,OAAO,GAAGF,OAAO,EAAvB;IACA,OAAOE,OAAP;EACD;;;GAvRcC,S,KAAAA,S"}