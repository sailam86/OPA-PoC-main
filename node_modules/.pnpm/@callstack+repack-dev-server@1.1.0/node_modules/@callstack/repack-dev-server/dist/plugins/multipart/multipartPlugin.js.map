{"version":3,"file":"multipartPlugin.js","names":["PassThrough","fastifyPlugin","CRLF","BOUNDARY","multipartPlugin","instance","asMultipart","request","headers","accept","undefined","stream","code","header","send","serializeHeaders","Object","keys","map","key","join","writeChunk","data","isLast","chunk","write","setHeader","name","value","end","decorateReply"],"sources":["../../../src/plugins/multipart/multipartPlugin.ts"],"sourcesContent":["import type { IncomingHttpHeaders } from 'http';\nimport { PassThrough } from 'stream';\nimport type { FastifyInstance, FastifyReply } from 'fastify';\nimport fastifyPlugin from 'fastify-plugin';\nimport type { MultipartHandler } from './types';\n\n/**\n * Implementation is based on:\n * https://github.com/facebook/metro/blob/347b1d7ed87995d7951aaa9fd597c04b06013dac/packages/metro/src/Server/MultipartResponse.js\n */\n\nconst CRLF = '\\r\\n';\nconst BOUNDARY = '3beqjf3apnqeu3h5jqorms4i';\n\nasync function multipartPlugin(instance: FastifyInstance) {\n  function asMultipart(this: FastifyReply): MultipartHandler | undefined {\n    // We should check if is included in accept or if accept has multipart/* or */*,\n    // but React Native will set accept to exactly `multipart/mixed`, so a simple check\n    // will suffice.\n    if (this.request.headers.accept !== 'multipart/mixed') {\n      return undefined;\n    }\n\n    const headers: IncomingHttpHeaders = {};\n    const stream = new PassThrough();\n\n    this.code(200)\n      .header('Content-Type', `multipart/mixed; boundary=\"${BOUNDARY}\"`)\n      .send(stream);\n\n    function serializeHeaders(headers: IncomingHttpHeaders) {\n      return Object.keys(headers)\n        .map((key) => `${key}: ${headers[key]}`)\n        .join(CRLF);\n    }\n\n    function writeChunk<T>(\n      headers: IncomingHttpHeaders,\n      data: T,\n      isLast?: boolean\n    ) {\n      let chunk = `${CRLF}--${BOUNDARY}${CRLF}`;\n      if (headers) {\n        chunk += serializeHeaders(headers) + CRLF + CRLF;\n      }\n\n      if (data) {\n        chunk += data;\n      }\n\n      if (isLast) {\n        chunk += `${CRLF}--${BOUNDARY}--${CRLF}`;\n      }\n\n      stream.write(chunk);\n    }\n\n    function setHeader(name: string, value: string | string[] | undefined) {\n      headers[name] = value;\n    }\n\n    function end<T>(data: T) {\n      writeChunk(headers, data, true);\n      stream.end();\n    }\n\n    return {\n      writeChunk,\n      setHeader,\n      end,\n    };\n  }\n\n  instance.decorateReply('asMultipart', asMultipart);\n}\n\nexport default fastifyPlugin(multipartPlugin, {\n  name: 'multipart-plugin',\n});\n"],"mappings":"AACA,SAASA,WAAT,QAA4B,QAA5B;AAEA,OAAOC,aAAP,MAA0B,gBAA1B;;AAGA;AACA;AACA;AACA;AAEA,MAAMC,IAAI,GAAG,MAAb;AACA,MAAMC,QAAQ,GAAG,0BAAjB;;AAEA,eAAeC,eAAf,CAA+BC,QAA/B,EAA0D;EACxD,SAASC,WAAT,GAAuE;IACrE;IACA;IACA;IACA,IAAI,KAAKC,OAAL,CAAaC,OAAb,CAAqBC,MAArB,KAAgC,iBAApC,EAAuD;MACrD,OAAOC,SAAP;IACD;;IAED,MAAMF,OAA4B,GAAG,EAArC;IACA,MAAMG,MAAM,GAAG,IAAIX,WAAJ,EAAf;IAEA,KAAKY,IAAL,CAAU,GAAV,EACGC,MADH,CACU,cADV,EAC2B,8BAA6BV,QAAS,GADjE,EAEGW,IAFH,CAEQH,MAFR;;IAIA,SAASI,gBAAT,CAA0BP,OAA1B,EAAwD;MACtD,OAAOQ,MAAM,CAACC,IAAP,CAAYT,OAAZ,EACJU,GADI,CACCC,GAAD,IAAU,GAAEA,GAAI,KAAIX,OAAO,CAACW,GAAD,CAAM,EADjC,EAEJC,IAFI,CAEClB,IAFD,CAAP;IAGD;;IAED,SAASmB,UAAT,CACEb,OADF,EAEEc,IAFF,EAGEC,MAHF,EAIE;MACA,IAAIC,KAAK,GAAI,GAAEtB,IAAK,KAAIC,QAAS,GAAED,IAAK,EAAxC;;MACA,IAAIM,OAAJ,EAAa;QACXgB,KAAK,IAAIT,gBAAgB,CAACP,OAAD,CAAhB,GAA4BN,IAA5B,GAAmCA,IAA5C;MACD;;MAED,IAAIoB,IAAJ,EAAU;QACRE,KAAK,IAAIF,IAAT;MACD;;MAED,IAAIC,MAAJ,EAAY;QACVC,KAAK,IAAK,GAAEtB,IAAK,KAAIC,QAAS,KAAID,IAAK,EAAvC;MACD;;MAEDS,MAAM,CAACc,KAAP,CAAaD,KAAb;IACD;;IAED,SAASE,SAAT,CAAmBC,IAAnB,EAAiCC,KAAjC,EAAuE;MACrEpB,OAAO,CAACmB,IAAD,CAAP,GAAgBC,KAAhB;IACD;;IAED,SAASC,GAAT,CAAgBP,IAAhB,EAAyB;MACvBD,UAAU,CAACb,OAAD,EAAUc,IAAV,EAAgB,IAAhB,CAAV;MACAX,MAAM,CAACkB,GAAP;IACD;;IAED,OAAO;MACLR,UADK;MAELK,SAFK;MAGLG;IAHK,CAAP;EAKD;;EAEDxB,QAAQ,CAACyB,aAAT,CAAuB,aAAvB,EAAsCxB,WAAtC;AACD;;AAED,eAAeL,aAAa,CAACG,eAAD,EAAkB;EAC5CuB,IAAI,EAAE;AADsC,CAAlB,CAA5B"}