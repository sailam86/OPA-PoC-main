/// <reference types="node" />
import type { Capability } from "@rnx-kit/config";
import type { AlignDepsConfig, Options, Preset } from "./types";
type Resolution = {
    devPreset: Preset;
    prodPreset: Preset;
    capabilities: Capability[];
};
export declare function ensurePreset(preset: Preset, requirements: string[]): void;
export declare function parseRequirements(requirements: string[]): [string, string][];
/**
 * Filters out any profiles that do not satisfy the specified requirements.
 * @param preset The preset to filter
 * @param requirements The requirements that a profile must satisfy
 * @returns Preset with only profiles that satisfy the requirements
 */
export declare function filterPreset(preset: Preset, requirements: string[]): Preset;
/**
 * Loads and merges specified presets.
 *
 * The order of presets is significant. The profiles from each preset are merged
 * when the names overlap. If there are overlaps within the profiles, i.e. when
 * multiple profiles declare the same capability, the last profile wins. This
 * allows users to both extend and override profiles as needed.
 *
 * @param presets The presets to load and merge
 * @param projectRoot The project root from which presets should be resolved
 * @returns Merged preset
 */
export declare function mergePresets(presets: string[], projectRoot: string, resolve?: NodeJS.RequireResolve): Preset;
/**
 * Loads specified presets and filters them according to the requirements. The
 * list of capabilities are also gathered from transitive dependencies if
 * `kitType` is `app`.
 * @param config User input config
 * @param projectRoot Root of the project we're currently scanniing
 * @param options
 * @returns The resolved presets and capabilities
 */
export declare function resolve({ kitType, alignDeps, manifest }: AlignDepsConfig, projectRoot: string, options: Options): Resolution;
export {};
//# sourceMappingURL=preset.d.ts.map