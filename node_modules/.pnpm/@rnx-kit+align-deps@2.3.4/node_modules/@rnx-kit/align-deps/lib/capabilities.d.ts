import type { Capability } from "@rnx-kit/config";
import type { PackageManifest } from "@rnx-kit/tools-node/package";
import type { MetaPackage, Package, Preset } from "./types";
type ResolvedDependencies = {
    dependencies: Record<string, Package[]>;
    unresolvedCapabilities: Record<string, string[]>;
};
/**
 * Returns the list of capabilities used in the specified package manifest.
 * @param packageManifest The package manifest to scan for dependencies
 * @param preset The preset to use to resolve capabilities
 * @returns A list of capabilities used in the specified package manifest
 */
export declare function capabilitiesFor({ dependencies, devDependencies, peerDependencies, }: PackageManifest, preset: Preset): Capability[];
export declare function capabilityProvidedBy(pkg: MetaPackage | Package): string | undefined;
export declare function isMetaPackage(pkg: MetaPackage | Package): pkg is MetaPackage;
/**
 * Resolves specified capabilities to real dependencies.
 * @param capabilities The list of capabilities to resolve
 * @param preset The preset to use to resolve capabilities
 * @returns A tuple of resolved dependencies and unresolved capabilities
 */
export declare function resolveCapabilitiesUnchecked(capabilities: Capability[], preset: Preset): ResolvedDependencies;
/**
 * Resolves specified capabilities to real dependencies.
 *
 * Same as {@link resolveCapabilitiesUnchecked}, but warns about any unresolved
 * capabilities.
 *
 * @param manifestPath The path to the package manifest
 * @param capabilities The list of capabilities to resolve
 * @param preset The preset to use to resolve capabilities
 * @returns Resolved dependencies
 */
export declare function resolveCapabilities(manifestPath: string, capabilities: Capability[], preset: Preset): Record<string, Package[]>;
export {};
//# sourceMappingURL=capabilities.d.ts.map